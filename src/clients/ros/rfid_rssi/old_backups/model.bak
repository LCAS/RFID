import rospy
import pickle
import sys
import tf

from std_msgs.msg import String
from nav_msgs.msg import *
from quaternions import *

tagLocations = []
tfListener = ""
TagLocations = (0, 1.6, 0)

gridSize = 8
gridResolution = 0.2

gridTotal = int(gridSize/gridResolution)

map = OccupancyGrid()
map.header.frame_id = "/base_link"
map.info.resolution = gridResolution
map.info.width = gridTotal * 2
map.info.height = gridTotal * 2
map.info.origin.position.x = -gridSize
map.info.origin.position.y = -gridSize
map.info.origin.position.z = 0
map.info.origin.orientation.w = 1
map.info.origin.orientation.x = 0
map.info.origin.orientation.y = 0
map.info.origin.orientation.z = 0
map.data = []
for i in xrange(0, int((gridTotal * 2) * (gridTotal * 2))):
	map.data.append(0)
pub = rospy.Publisher("/rfid/ocmap", OccupancyGrid, queue_size=10)

def tagCallback(data):
	
	if not tfListener.frameExists("/base_link"):
		print "Error finding tf frame for base link"
		return
	if not tfListener.frameExists("/odom_combined"):
		print "Error finding tf frame for odom"
		return

	
	now = rospy.Time(0)
	tfListener.waitForTransform("odom_combined", "base_link", now, rospy.Duration(4.0))
	position, quat = tfListener.lookupTransform("/odom_combined", "/base_link", now)

	data = str(data)
	data = data.split(":")
	tagID = data[2]
	freq = data[5]
	rssi = data[3]
	tx = 3000




	relativePosition = (TagLocations[0] - position[0], TagLocations[1] - position[1], TagLocations[2] - position[2])

	rotx, roty, rotz = calculateEuler(quat[0], quat[1], quat[2], quat[3])

	xt = TagLocations[0] - position[0]
	yt = TagLocations[1] - position[1]
	x = xt * cos(-rotx) - yt * sin(-rotx)
	y = xt * sin(-rotx) + yt * cos(-rotx)
	z = 0

	v = quaternionVectorMult(quat, relativePosition)

	rssi = int(rssi)
	rssi = rssi * -2
	rssi = rssi - 60
	setMapValue(x, y, rssi)

	pub.publish(map)

def setMapValue(x, y, val):
	if x > gridTotal or y > gridTotal or -x > gridTotal or -y > gridTotal:
		return
	else:
		yoffset = ((y - (y % gridResolution)) + gridSize) / gridResolution
		xoffset = ((x - (x % gridResolution)) + gridSize) / gridResolution
		index = (gridTotal * 2 * yoffset) + xoffset

		map.data[int(index)] = val

def main():

	global tfListener
	
	args = sys.argv
	del args[0]

	if len(args) == 0:
		print "Error: No tags to build model from"
		return

	for i in args:
		i = i.split(":")
		#tagLocations.append(i)

	rospy.init_node("buildModel")
	tfListener = tf.TransformListener()
	rfidSub = rospy.Subscriber("rfid/rfid_detect", String, tagCallback)

	rospy.spin()

	
if __name__ == "__main__":
	main()
